#summary Description of Optimization Passes

<wiki:toc max_depth="2" />

= Optimization Passes =

MAO comes with a set of analysis, transformation, and optimization passes. The invocation order is determined by the user via the command line interface, the order in which passes are specified will be the order in which the passes are executed.

Since MAO is a young project, some passes are developed more than others, and some might not make sense at all. In this document, we keep the current status for the various passes.

== ZEE - Zero Extension Elimination ==
=== Source ===
{{{ 
  MaoZee.cc 
}}}
=== Description ===
This pass seeks to eliminate redundant zero extensions. It is a local optimization and only operates in a basic block. 

In 64-bit compilation models, performing an operation on a 32-bit part of a 64-bit register will, be default, zero-extend the upper 32-bit of that register. An explicit zero-extent operation of the following form is often used in generated code:
{{{
    movl reg32, same-reg32
}}}

However, when this mov is preceeded by a 32-bit operation on reg32, this instruction is redundant. For example:
{{{
[ZEE]   Found redundant zero-extend:
        shrl    $8, %ecx        # id: 132, l: 166       
        movl    %ecx, %ecx      # id: 133, l: 167   
}}}

This pass checks for possible definitions of reg32 between the 1st assignment and the possinly redundant movl. If there is none, the movl can be eliminated.

=== Extensions ===
This pass can be greatly enhanced. It should look across basic blocks for dead zero-extends. We've also identified an overlapping assignment, e.g., 
{{{
[ZEE]   Overlap
        movq    (8)(%rdi), %rax # id: 5661, l: 6300     
        movl    %eax, %eax      # id: 5662, l: 6301     
}}}
which is not yet handled.

== REDTEST - Redundant Test Removal ==
=== Source ===
{{{
  MaoRedundantTestElim.cc
}}}

=== Description ===

This pass seeks to eliminate redundant test instructions.  It is a local optimization and only operates in a basic block. 

Within gcc, for x86, flags are not modeled with best precision. Instead, the flags are all lumped together in one pseudo operand in the compiler IR.

Correspondingly, the compiler can oftentimes not properly determine whether a test instructions is needed, or whether flags have been set properly by a preceding operation. As a result, we find many patterns of this form:

{{{
   subl     xxx, %r15d
   ... instructions not setting flags
   testl    %r15d, %r15d
}}}

The pass implementation is fairly straightforward. It finds test instructions with identical registers, and then peeks upwards, passing (only) over mov instructions (not defining the register used in the test instructions), which do not set flags, until it finds an add, sub, and, or, xor, or sbb instruction defining the same register. If such test instruction is found, it is removed.

=== Extensions ===
This pass can be extended to handle the sar, shr, sal, shl as well. However, the flag logic for these operations is non-canonical, and proper handling will be difficult. The pass can also be extended to work across basic blocks (expect little benefit)

== REDMOV - Redundant Memory Move Elimination ==
=== Source ===
{{{
  MaoRedundantMemMove.cc
}}}
=== Description ===
This pass seeks to remove memory operations. It is a local pass and only works in a basic block.

Because of various (phase ordering) issues, compiler oftentimes generate code of the following form to load from memory:
{{{
    movq    24(%rsp), %rdx
    ... no def for this memory,
    ... no def for the right hand side register %rdx,
    movq    24(%rsp), %rcx
}}}

We find that the 2nd movg address operation is not necessary and the instruction can be replaced by:
{{{
  //  movq    %rdx, %rcx
}}}
This instruction has a shorter encoding and avoids a 2nd memory reference.


The implementation of this pass is somewhat interesting, as it has to check, whether the address in the instruction aliases with any instruction in between the two moves. It makes use of the infrastructure to determine whether registers overlap and/or are defined between the instructions. 

=== Caveats ===
The current implementation might be a little too optimistic. There is a question around multi-threaded code. We believe the transformation is legal for the current C++ memory model. There is also an issue around performance, this pass does not seem to help. Work in progress.

== LOOP16 - Align very tiny loops ==
=== Source ===
{{{
  MaoLoop16
}}}
=== Description ===
This pass seeks to align very tight loops to 16-byte boundaries to avoid incurring an instruction fetch penalty. This problem was discovered analyzing a 9% degradation in 252.eon on Ilium.

Very tiny loops, e.g., loops that are shorter than 32-byte, should be aligned to 16-byte boundaries to minimize the number of fetch lines. Thiss pass looks at inner loops, it checks whether pushing the starting address down would reduce the number of required fetch lines. IN particular, it checks whether more bytes are available in the last fetch lines than are used in the 1st fetchline. For example:
{{{
         |0123456789012345|
         |.........BBBBBBB|   these bytes are used by loop
         |XXXXXXXXXXXXXXXX|*  any number of filled lines
         |EEEEEEE---------|   there need to be more -'s than B's
}}}

The pass implementation is somewhat interesting, it makes use of the loop structure graph, multiple relaxations, and displays how to get to instruction offsets and sizes within MAO.

=== Extensions ===
The current heuristics are somewhat braindead - it only aligns loops with 2 or less fetchlines. A more thorough analysis might find more opportunity.

== NOPKILL - Remove Alignments ==
=== Source ===
{{{
  MaoNopKiller.cc
}}}
=== Description ===
=== Extensions ===

== NOPIN - Insert Random Nops ==
=== Source ===
{{{
  MaoNopinizer.cc
}}}
=== Description ===
=== Extensions ===

== BACKBRALIGN - Back Branch Alignment ==
=== Source ===
{{{
  MaoBackBranchAlign.cc
}}}
=== Description ===
=== Extensions ===

== PREFNTA - Simple Prefetch Insertion ==
=== Source ===
{{{
  MaoPrefetchNta.cc
}}}
=== Description ===
=== Extensions ===

== SCHED - Instruction Scheduling ==
=== Source ===
{{{
  MaoScheduler.cc
}}}
=== Description ===
=== Extensions ===



== ADDADD - Remove Redundant Adds ==
=== Source ===
{{{
  MaoAddAdd.cc
}}}
=== Description ===
=== Extensions ===



= Analysis Passes =
These passes perform some analysis. Typically, we would implement the analysis first. If a particular pattern cannot be found, we keep it at that and don't bother implementing the corresponding transformations.

== LFIND - Loop Recognition ==
=== Source ===
{{{
  MaoLoops.cc
}}}
=== Description ===
This path performs fast loop recognition based on Paul Havlak's paper "Nesting of Reducible and Irreducible Loops", Rice University.

We avoid doing tree balancing and instead use path compression to avoid traversing parent pointers over and over. This is a small extension to the original paper. In the implementation, most of the variable names and identifiers are taken literally from this paper (and the original Tarjan paper mentioned above)

== DCE - Unreachable Code Removal ==
=== Source ===
{{{
  MaoDCE.cc
}}}
=== Description ===
This pass seeks to find unreachable basic blocks. 

The basic assumption is that a reasonable compiler would not leave any unreachable code in a produced asm file. This pass is therefore mainly used for quality assurance for compiler _and_ MAO's control flow implementation.

However, once MAO is hooked up to a threaded VM, these kinds of simple scalar optimizations will become relevant. 

For now, only analysis has been implemented. It is a straightforward pass and can be used to learn about the CFG implementation.


== MISSDISP - Find missing displacement ==
Analysis Pass.

=== Source ===
{{{
  MaoMissDisp.cc
}}}
=== Description ===
This pass seeks to transform this pattern:
{{{
   add    $0x8,%rax
   mov    (%rax),%rax
}}}
into this instruction:
{{{
   mov    0x8(%rax),%rax
}}}

It is a local optimization and only operates in a basic block. 

We only found this code in gcc compiled code at optimization level -O0. It provides a good and simple example for how to check for patterns. Currently, it does *not* perform the transformation. We didn't bother to implement the transformation, as we didn't find real instances in code that matters.