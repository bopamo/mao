#summary Description of Optimization Passes

= Optimization Passes =

MAO comes with a set of analysis, transformation, and optimization passes. The invocation order is determined by the user via the command line interface, the order in which passes are specified will be the order in which the passes are executed.

Since MAO is a young project, some passes are developed more than others, and some might not make sense at all. In this document, we keep the current status for the various passes.


= ZEE - Zero Extension Elimination =
=== Source ===
{{{ 
  MaoZee.cc 
}}}
=== Description ===
This pass seeks to eliminate redundant zero extensions. It is a local optimization and only operates in a basic block. 

In 64-bit compilation models, performing an operation on a 32-bit part of a 64-bit register will, be default, zero-extend the upper 32-bit of that register. An explicit zero-extent operation of the following form is often used in generated code:
{{{
    movl reg32, same-reg32
}}}

However, when this mov is preceeded by a 32-bit operation on reg32, this instruction is redundant. For example:
{{{
[ZEE]   Found redundant zero-extend:
        shrl    $8, %ecx        # id: 132, l: 166       
        movl    %ecx, %ecx      # id: 133, l: 167   
}}}

This pass checks for possible definitions of reg32 between the 1st assignment and the possinly redundant movl. If there is none, the movl can be eliminated.

=== Extensions ===
This pass can be greatly enhanced. It should look across basic blocks for dead zero-extends. We've also identified an overlapping assignment, e.g., 
{{{
[ZEE]   Overlap
        movq    (8)(%rdi), %rax # id: 5661, l: 6300     
        movl    %eax, %eax      # id: 5662, l: 6301     
}}}
which is not yet handled.

= REDTEST - Redundant Test Removal =
=== Source ===
{{{
  MaoRedundantTestElim.cc
}}}

=== Description ===

This pass seeks to eliminate redundant test instructions.  It is a local optimization and only operates in a basic block. 

Within gcc, for x86, flags are not modeled with best precision. Instead, the flags are all lumped together in one pseudo operand in the compiler IR.

Correspondingly, the compiler can oftentimes not properly determine whether a test instructions is needed, or whether flags have been set properly by a preceding operation. As a result, we find many patterns of this form:

{{{
   subl     xxx, %r15d
   ... instructions not setting flags
   testl    %r15d, %r15d
}}}

The pass implementation is fairly straightforward. It finds test instructions with identical registers, and then peeks upwards, passing (only) over mov instructions (not defining the register used in the test instructions), which do not set flags, until it finds an add, sub, and, or, xor, or sbb instruction defining the same register. If such test instructions is found, it is removed.

=== Extensions ===
This pass can be extended to handle the sar, shr, sal, shl as well. However, the flag logic for these operations is non-canonical, and proper handling will be difficult.