This page discusses MAO's internal representation(IR) and the important APIs to access and manipulate the IR. This document does not serve as a complete documentation of all the classes that implement MAO's core IR. Instead, it gives an overview of the classes and describes some of the important methods that will be useful to a developer.

<wiki:toc max_depth="2" />

MAO stores a program as a list of _entries_ which roughly correspond to lines in the assembly file. While this makes the representation simple, it does not provide a very rich interface to access and manipulate the IR. So MAO provides a hierarchy of views that are useful to the developer.

== Unit == 
The topmost level in this hierarchy is the `MaoUnit` class. This class corresponds to an entire assembly program and contains a vector of pointers to `MaoEntry` objects. This entry vector is not directly accessed from `MaoUnit`. Instead, it provides iterators to access _sections_ and _functions_ that are represented by the `Section` and `Function` classes respectively. The following methods in `MaoUnit` enable iterating over the sections and the functions.

{{{
  SectionIterator SectionBegin();
  SectionIterator SectionEnd();
  ConstSectionIterator ConstSectionBegin() const;
  ConstSectionIterator ConstSectionEnd() const;
  FunctionIterator FunctionBegin();
  FunctionIterator FunctionEnd();
  ConstFunctionIterator ConstFunctionBegin() const;
  ConstFunctionIterator ConstFunctionEnd() const;
}}}

The entries in `MaoUnit` are not replicated in other hierarchical containers under `MaoUnit`. Instead, they typically keep a pointer to the first and last entries in the hierarchy.

In addition, `MaoUnit` provides other useful methods that are found in `MaoUnit.h` and `MaoUnit.cc`.

== Sections and Subsections ==
A section in an assembly file corresponds to `.section` directives in the assembly file with the same name and is represented by the `Section` class. For instance, every entry between `.section text` and the next `.section` directive is represented by one `Section` object.  The entries in a Section can be iterated over using the following methods:
{{{
  SectionEntryIterator EntryBegin() const;
  SectionEntryIterator EntryEnd() const;
}}}
The `Section` class also contains a vector of `SubSection` pointers. The GNU assembler allows subsections that are not contiguous in the assembly file, but considered as belonging to the same section. A subsection is represented by the `SubSection` class. The method `std::vector<SubSectionID> GetSubsectionIDs()` returns a cetor of subsection IDs in a given section. These ids can be passed to the `SubSection *GetSubSection(unsigned int subsection_number)` method of `MaoUnit` to get the `SubSection` pointer. The `SubSection` class stores pointers to the first and the last entry within the subsection. It provides the methods
{{{
  SectionEntryIterator EntryBegin();
  SectionEntryIterator EntryEnd();
}}}
to iterate over the entries within the subsection. 

== Function ==
Many optimization passes operate at a function level and hence it is important to group a sequence of entries into functions. The `Function` class represents a function. It contains pointers to the first and last entries, the enclosing subsection and the enclosing section.  The following methods enable iterating over the entries of a function: 

{{{
  SectionEntryIterator EntryBegin();
  SectionEntryIterator EntryEnd();
}}}

Internally, the `Function` class also stores pointers to the control flow graph (CFG) and the loop structure graph (LSG). These data structures are not directly accessed from a `Function` object. Instead, the CFG and LSG classes provide methods to obtain the CFG or LSG for a given `Function`.

== Entry == 
An entry corresponds to a non-comment line in the assembly file and is represented by the `MaoEntry` class. `MaoEntry` is a pure abstract class. It is derived by `InstructionEntry`, `LabelEntry` and `DirectiveEntry` classes. The base class `MaoEntry` implements the following methods common to all the derived classes that return the previous and next entries in the `MaoUnit`:
{{{
  MaoEntry *next()
  MaoEntry *prev()
}}}

The following methods in `MaoEntry` help to determine the specific type of an entry:
{{{
  bool IsInstruction()
  bool IsLabel() 
  bool IsDirective()
}}}

and the following methods help to cast a `MaoEntry` pointer to a specific type:
{{{
  InstructionEntry *AsInstruction();
  LabelEntry *AsLabel();
  DirectiveEntry *AsDirective();
}}}

== Directive ==
The `DirectiveEntry` class represents assembler directives such as `.byte`, `.word`, `.p2align`, etc. A directive consists of an opcode and a vector of operands. The operands are represented by an inner `Operand` class. The opcode of the directive is returned by the `op()` method and the `const Operand *GetOperand(int num)` returns a particular operand of the directive.

== Label ==

== Instruction ==