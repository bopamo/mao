#summary How to run and integrate MAO.

= Running Standalone MAO =

After building MAO, for each build target, a binary called {{{mao-$TARGET}}} will be placed in 
{{{./bin/.}}} For example, building a 64-bit MAO on Linux produces {{{./bin/mao-x86_64-linux}}}.

The MAO binary accepts all flags accepted by the GNU Assembler, and as a matter of fact, all flags are passed on to the integrated assembler. To specify MAO specific options, use the option {{{--mao=...}}}. Everything specified after the {{{--mao=}}} will be parsed by MAO and taken off the arguments passed to the integrated assembler. 

Multiple MAO options can be specified on the command line. 

Additionally, the environment variable MAOOPTS can be set. This environment variable is parsed before the actual command line parameters. It should only contain MAO specific options, without the {{{--mao=}}} prefix.

Please find more details on how to specify MAO options in OptionHandling.

= Passes =
Everything MAO does is organized in passes. There is a pass to read an input assembly file. This pass is enabled by default. There are various analysis, transformation, and optimization passes, and there is an ASM pass which write the IR to a valid assembly file.

In order to get anything done with MAO, the sequence of passes must be specified on the command line (or, later, in a control file). This is done via the {{{--mao=...}}} option. Specifying a pass on the command line enables the pass and puts it in sequence with the other specified passes. 

Passes cannot be enabled or disabled. If they are on the command-line, they are sequenced in and enabled. If they are not on the command-line, they are not executed.

Certain passes perform analysis, for example, to build a control flow graph, or to perform loop recognition. These passes do *not* need to be specified explicitly. If, for example, an optimization pass requires such analysis, it will explicitly call that particular pass.

For example:
{{{
  ../bin/mao-x86_64-linux --mao=:ZEE:ASM=o[/dev/stderr] input.s
}}}
would open and read the file input.s (that's done by default). Then pass ZEE is executed, before pass ASM is executed. The ASM pass got a parameter to define the output file (/dev/stderr) in the example.

Another example:
{{{
  ../bin/mao-x86_64-linux  --mao=ZEE=trace:REDTEST=trace:REDMOV=trace \
                           --mao=LOOP16=trace:BACKBRALIGN=trace[0] input.s
}}}
will invoke the phases ZEE, REDTEST, REDMOV, LOOP16 and BACKBRALIGN in this sequence. This example is missing the ASM pass at the end, so there would be no output generated. This can be useful to run, e.g., analysis only passes.

= Default Output =
The default output of MAO goes to stdout via the pass ASM. To change the output file, the option 'o' to 'ASM' can be used. For example:

{{{
  # redirect output to stderr
  ../bin/mao-x86_64-linux --mao=:ZEE=trace:ASM=o[/dev/stderr] input.s

  # kill all output
  ../bin/mao-x86_64-linux --mao=ASM=o[/dev/null] input.s

  # simple omit the ASM pass will also not create output
  ../bin/mao-x86_64-linux input.s

}}}

To see all available options and passes, start MAO with the --mao=-h command line parameter. e.g.

{{{
  # print all available command line options and descriptions
  ../bin/mao-x86_64-linux --mao=-h
}}}

= Integrating MAO with gcc =

The gcc compiler runs its input through a preprocessor and then through either cc1 or cc1plus to generate an assembly file, which is usually a temporary file in {{{/tmp/...}}} (Note: Modern versions of gcc combine the preprocessor and cc1 into one pass). The compiler driver then call the GNU assembler 'as' to produce the final object file. 

For example, to compile foo.cc, the compiler might call:

{{{
$ gcc -o foo.o foo.cc
  ...cc1 -quiet hello.c -o /tmp/cciDot0H.s
  ...as  -V -Qy -o hello.o /tmp/cciDot0H.s
}}}

In order to benefit from MAO optimizations, it should be run right before the GNU assembler. The easiest way to do this is to replace the 'as' with a script which executes MAO first, and then start 'as' on MAO's output. 

We wrote such a wrapper script and put it in {{{ mao/scripts/as_wrapper.sh }}}.

To squeeze this script into gcc, you can:

   # Replace the 'as' directly. For example, rename it, and put a wrapper script named 'as' in its original place, which runs MAO and the former orginal assembler. This method has the drawback that MAO will always be executed.
   # Recommended: Pass the -Bpath option to gcc and place the 'as' wrapper script into the specified path. gcc will look into these paths first, and if it finds an 'as' it will execute it from there. This method allows to selectively apply MAO to compilations. The scripts directory in MAO's base directory may be used, however, soft links to 'mao' and 'as-orig' (as-orig should link to your original gas 'as' binary) must be created\.  After doing this, simply add "-B/MAODIR/scripts" to your gcc command line and pass MAO directives using "-Wa,--mao=..." e.g.
{{{
$ gcc test.c -o test -B/home/username/mao/scripts/gcc_hook -Wa,--mao=ASM=o[mao_test.s]
}}}
   # This method is similar to point 2, instead of passing the -B option, the enviroment variable GCC_EXEC_PREFIX can be set.

= Integrating MAO with Open64 =

The open64 compiler re-uses parts of an existing gcc installation. In particular, it also re-uses 'as' and has support for {{{-B}}}, as well as it's own options allowing to specify various parts of the toolchain {{{-y...}}}. The same tricks as above apply.