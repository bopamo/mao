#
# Copyright 2008 Google Inc.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, 5th Floor, Boston, MA 02110-1301, USA.

# Side effect table for instructions
#
# memnonic  defs
#
# with defs being one of:
#    reg    all valid register names are supported. Taking the register
#           names from binutils-2.xx/opcodes/i386-reg.tbl
#
#    op0    instruction def's operand 0  (also 'src')
#    op1    instruction def's operand 1  (also 'dest')
#    ...
#
#    addr8: all following registers are def'ed in case
#           op0 of the instruction denotes an 8-bit reg
#           or mem. Note: The colon : is required.
#    addr16:
#    addr32:
#    addr64: correspondingly.
#
#    flags: starting to define flags. Valid flag names are:
#          CF PF AF ZF SF TP IF DF OF IOPL NT RF VM AC VIF VIP ID
#
#    clear: indicate which flags are cleared.
#    undef: indicate which flags are left undefined.
#
#    all:  switches back to default mask and def assignment.
#
aaa   ax flags: AF CF
aad   ax flags: SF ZF PF undef: OF AF CF
aam   ax flags: SF ZF PF undef: OF AF CF
aas   ax flags: AF CF undef: OF SF ZF PF
adc   dest flags: OF SF ZF AF PF CF
add   dest flags: OF SF ZF AF PF CF
addpd dest
addps dest
addsd dest
addss dest
and   dest flags: SF ZF PF clear: OF CF undef: AF
andpd dest
andps dest
andnpd dest
andnps dest
arpl dest flags: ZF

blendpd dest
blendps dest
blendvpd dest
blendvps dest
bound 
bsf dest flags: ZF undef: CF OF SF AF PF
bsr dest flags: ZF undef: CF OF SF AF PF
bswap src dest
bt flags: CF undef: OF SF AF PF ZF
btc src dest flags: CF undef: OF SF ZF AF PF
btr src dest flags: CF undef: OF SF ZF AF PF
bts src dest flags: CF undef: OF SF ZF AF PF

call rax rcx rdx rsi rdi r8 r9 r10 r11 flags: CF ZF SF OF PF AF
cbw  ax
cwde eax
cdqe rax
clc clear: CF
cld clear: DF
clflush
cli clear: IF VIF
clts cr0
cmc flags: CF

cmovo   dest
cmovno  dest
cmovb   dest
cmovc   dest
cmovnae dest
cmovae  dest
cmovnc  dest
cmovnb  dest
cmove   dest
cmovz   dest
cmovne  dest
cmovnz  dest
cmovbe  dest
cmovna  dest
cmova   dest
cmovnbe dest
cmovs   dest
cmovns  dest
cmovp   dest
cmovnp  dest
cmovl   dest
cmovnge dest
cmovge  dest
cmovnl  dest
cmovle  dest
cmovng  dest
cmovg   dest
cmovnle dest

#TODO: Refine the cmp instruction into various cmpcc forms
cmp   flags: CF OF SF PF AF ZF
cmppd dest
cmpps dest

#cmpsb, cmpsw and cmpsq are represented as cmps in the opcode table
#The instruction entry doesn't have an operand and hence there is no
#good way to determine the addr size (without looking at the opcode).
#So conservatively assume all registers are defed in all modes
cmps   di si edi esi rsi rdi flags: CF OF AF ZF SF PF
cmpsd  addr8: di si addr16: di si addr32: edi esi addr64: rsi rdi

# these three are mentioned in the Intel manual, but don't have
# an explicit entry in the opcode tables.
# cmpsb  addr8: di si addr16: di si addr32: edi esi addr64: rsi rdi
# cmpsw  addr8: di si addr16: di si addr32: edi esi addr64: rsi rdi
# cmpsq  addr8: di si addr16: di si addr32: edi esi addr64: rsi rdi

cmpxchg dest addr8: al addr16: ax addr32: eax addr64: rax
cmpxchg8b dest edx eax ecx ebx
cmpxchg16b dest rdx rax rcx rbx
comisd
comiss
cpuid eax ebx ecx edx
crc32 dest
cvtdq2pd dest
cvtdq2pd dest
cvtpd2dq dest
cvtpd2dq dest
cvtdq2ps dest
cvtdq2ps dest
cvtpd2pi dest
cvtpd2ps dest
cvtpd2ps dest
cvtps2pd dest
cvtps2pd dest
cvtps2dq dest
cvtps2dq dest
cvtsd2si dest
cvtsd2si dest
cvtsd2ss dest
cvtsd2ss dest
cvtss2sd dest
cvtss2sd dest
cvttpd2pi dest
cvttsd2si dest
cvttsd2si dest
cvttpd2dq dest
cvttpd2dq dest
cvttps2dq dest
cvttps2dq dest

cwd dx ax
cdq edx eax 
cqo rdx rax

daa al
das al
dec op0 flags: OF SF ZF AF PF
div addr8: ax addr16: ax dx addr32: eax edx addr64: rax rdx undef: CF OF SF ZF AF PF
divpd dest
divps dest
divsd dest
divss dest
dppd dest
dpps dest

emms

# can be refined by compilation mode (16/32/64)
enter rbp rsp
extractps dest

# floating point instructions
# f*
# ignore for now, escept:
fist
fistp
fistpll
fisttp
fisttpll

hlt

idiv      addr8: ax addr16: ax dx addr32: eax edx addr64: rdx rax undef: CF OF SF ZF AF PF
imul dest addr8: ax addr16: ax dx addr32: eax edx addr64: rdx rax flags: CF OF undef: SF ZF AF PF

in   dest
inc  src

# can be refined by mode
ins  rdi 
# these three are in the Intel manual, but taken care of by the mode
# append trick in mao/gas
#
# insb rdi
# insw rdi
# insd rdi
insertps dest
#
int rax rcx rdx rsi rdi r8 r9 r10 r11
into rax rcx rdx rsi rdi r8 r9 r10 r11
invd 
invlpg
#TODO iret
#iret
# described in the Intel manual, but taken care of by the mode
# append trick in mao/gas
# iretd

# jumpers - don't modify regs.
jmp
ljmp
jo
jno
jb
jc
jnae
jnb
jnc
jae
je
jz
jne
jnz
jbe
jna
jnbe
ja
js
jns
jp
jpe
jnp
jpo
jl
jnge
jnl
jge
jle
jng
jnle
jg

jcxz
jecxz
jecxz
jrcxz

lahf  ah
lar   dest
lddqu dest

ldmxcsr mxcsr
lds dest ds
lss dest ss
les dest es
lfs dest fs
lgs dest gs

lea   dest
leave rsp rbp
lfence 
lgdt
lidt
lldt
lmsw src
lock
lods  addr8: al addr16: ax addr32: eax addr64: rax
# these are in the Intel manual, but taken care of by the mode
# append trick in mao/gas
# lodsb al
# lodsw ax
# lodsd eax
# lodsq rax

# loops can be refined by address size
loop   rcx
loope  rcx
loopne rcx
loopz  rcx
loopnz rcx

lsl dest
ltr src
maskmovdqu dest
maskmovq dest
maxpd dest
maxps dest
maxsd dest
maxss dest
mfence
minpd dest
minps dest
minsd dest
minss dest
monitor 
# movers and shakers
mov  dest
movapd dest
movaps dest
movabs dest
movd dest
movddup dest
movdqa dest
movdqu dest
movdq2q dest
movhlps dest
movhpd dest
movhps dest
movlhps dest
movlpd dest
movlps dest
movmskpd dest
movmskps dest
movntdqa dest
movntdq dest
movnti dest
movntpd dest
movntps dest
movntq dest
movq dest
movq2dq dest

movsd  dest ecx addr8: si di addr16: si di addr32: esi edi addr64: rsi rdi
movs   dest ecx addr8: si di addr16: si di addr32: esi edi addr64: rsi rdi
# taken care of by mode append
# movsb  dest ecx addr8: si di addr16: si di addr32: esi edi addr64: rsi rdi
# movsw  dest ecx addr8: si di addr16: si di addr32: esi edi addr64: rsi rdi
# movsq  dest ecx addr8: si di addr16: si di addr32: esi edi addr64: rsi rdi

movsbl dest ecx addr8: si di addr16: si di addr32: esi edi addr64: rsi rdi
movsbw dest ecx addr8: si di addr16: si di addr32: esi edi addr64: rsi rdi
movswl dest ecx addr8: si di addr16: si di addr32: esi edi addr64: rsi rdi
movslq dest ecx addr8: si di addr16: si di addr32: esi edi addr64: rsi rdi

# there is a floating point movsd as well?
# movsd

movupd dest
movups dest

# various zero and sign extent moves.
movbe dest
movsbl dest
movsbw dest
movswl dest
movsbq dest
movswq dest
movslq dest
movsx dest
movsxd dest

movzbl dest
movzbw dest
movzbl dest
movzbq dest
movzbq dest
movzwl dest
movzwq dest
movzx dest

mpsadbw dest
mul   dest addr8: ax addr16: ax dx addr32: eax edx addr64: rdx rax flags: OF CF undef: SF ZF AF PF
mulpd dest
mulps dest
mulsd dest
mulss dest

mwait

# SSE3 instructions
# TODO: sort them in...
addsubpd dest
addsubps dest
haddpd dest
haddps dest
hsubpd dest
hsubps dest
lddqu dest
movddup dest
movshdup dest
movsldup dest


# N
neg  op0  flags: CF OF SF ZF AF PF
nop       flags: 
not  op0

# O
or   dest flags: SF ZF PF clear: OF CF undef: AF
orpd dest
orps dest
out       flags:
outs  addr8: si addr16: si addr32: esi addr64: rsi  flags:
# taken care of by mode append:
# outsb addr8: si addr16: si addr32: esi addr64: rsi  flags:
# outsw addr8: si addr16: si addr32: esi addr64: rsi  flags:
# outsd addr8: si addr16: si addr32: esi addr64: rsi  flags:

# P
pabsb dest
pabsw dest
pabsd dest
packsswb dest  flags:
packssdw dest  flags:
packusdw dest  flags:
packuswb dest  flags:
paddb    dest  flags:
paddw    dest  flags:
paddd    dest  flags:
paddq    dest  flags:
paddsb   dest  flags:
paddsw   dest  flags:
paddusb  dest  flags:
paddusw  dest  flags:
palignr  dest  flags:
pand     dest  flags:
pandn    dest  flags:
pause          flags:
pavgb    dest  flags:
pavgw    dest  flags:
pblendvb dest  flags:
pblendw  dest  flags:
pcmpeqb  dest  flags:
pcmpeqw  dest  flags:
pcmpeqd  dest  flags:
pcmpeqq  dest  flags:
pcmpestri dest eax ecx edx xmm0 addr64: rax rdx xmm0 flags:
pcmpestrm dest eax ecx edx xmm0 addr64: rax rdx xmm0 flags:
pcmpistri addr8: ecx addr16: ecx addr32: ecx addr64: rcx flags:
pcmpistrm xmm0 flags:
pcmpgtb  dest
pcmpgtw  dest
pcmpgtd  dest
pcmpgtq  dest
pextrb   dest
pextrd   dest
pextrq   dest
pextrw   dest
phaddw   dest
phaddd   dest
phaddsw  dest
phminposuw dest
phsubw   dest
phsubd   dest
phsubsw  dest
pinsrb   dest
pinsrd   dest
pinsrq   dest
pinsrw   dest
pmaddubsw dest
pmaddwd   dest
pmaxsb    dest
pmaxsd    dest
pmaxsw    dest
pmaxub    dest
pmaxud    dest
pmaxuw    dest
pminsb    dest
pminsd    dest
pminsw    dest
pminub    dest
pminud    dest
pminuw    dest
pmovmskb  dest

pmovsxbw  dest
pmovsxbd  dest
pmovsxbq  dest

pmovsxwd  dest
pmovsxwq  dest
pmovsxdq  dest

pmovzxbw  dest
pmovzxbd  dest
pmovzxbq  dest
pmovzxwd  dest
pmovzxwq  dest
pmovzxdq  dest

pmuldq    dest
pmulhrsw  dest
pmulhuw   dest
pmulhw    dest
pmulld    dest
pmullw    dest
pmuludq   dest
pop   rsp op0

popa  rsp  di  si  bp  bx  dx  cx  ax  flags:
# taken care of by mode append
# popad rsp edi esi ebp ebx edx ecx eax  flags:

popcnt    dest  clear: OF SF ZF AF CF PF flags: ZF
popf  rsp  eflags

# taken care of by mode append
# popfd rsp  eflags
# popfq rsp  rflags
por    dest

# These three prefetches are named differently in the Intel manual:
# prefetch0, prefetch1, prefetch2
#
prefetcht0 dest
prefetcht1 dest
prefetcht2 dest

prefetchnta dest
psadbw  dest
pshufb  dest
pshufd  dest
pshufhw dest
pshuflw dest
pshufw  dest
psignb  dest
psignw  dest
psignd  dest
pslldq  dest
psllw   dest
pslld   dest
psllq   dest
psraw   dest
psrad   dest
psrldq  dest
psrlw   dest
psrld   dest
psrlq   dest
psubb   dest
psubw   dest
psubd   dest
psubq   dest
psubsb  dest
psubsw  dest
psubusb  dest
psubusw  dest
ptest    clear: OF AF PF SF flags: ZF CF

# For punpckh.. and punpckl.., Intel and AT&T differ in the final
# characters.
#
punpckhbw  dest
punpckhdq  dest
punpckhwd  dest

punpcklbw  dest
punpckldq  dest
punpcklwd  dest

punpckhqdq dest
punpcklqdq dest

# TODO: refine by build model
push   rsp flags:
pusha  rsp
# taken care of by mode append:
# pushad rsp

pushf  rsp
# taken care of by mode append:
# pushfd rsp
# pushfq rsp

pxor   dest

# R
rcl dest flags: CF undef: OF
rcr dest flags: CF undef: OF
rol dest flags: CF undef: OF
ror dest flags: CF undef: OF
rcpps dest
rcpps dest
rdmsr edx eax flags:
rdpmc edx eax flags:
rdtsc edx eax flags:
rdtscp edx eax ecx flags:

#reps are tricky to handle since their operands is based
#on what follows the rep. Handle them conservatively
#Further complicated by th fact that registers used depends
#on REX prefix
rep  cx ecx rcx
repe  cx ecx rcx
repz  cx ecx rcx
repne  cx ecx rcx
repnz  cx ecx rcx

ret   rip rsp
roundpd  dest
roundps  dest
roundsd  dest
roundss  dest
rsm
rsqrtps  dest
rsqrtss  dest

# S
sahf eflags flags: SF ZF AF PF CF
sal dest flags: OF SF ZF PF undef: AF
sar dest flags: OF SF ZF PF undef: AF
shl dest flags: OF SF ZF PF undef: AF
shr dest flags: OF SF ZF PF undef: AF
sbb dest flags: OF SF ZF AF PF CF
scas  addr8: di addr16: di addr32: edi addr64: rdi flags: OF SF ZF AF PF CF
# taken care of by mode append:
# scasb addr8: di addr16: di addr32: edi addr64: rdi flags: OF SF ZF AF PF CF
# scasw addr8: di addr16: di addr32: edi addr64: rdi flags: OF SF ZF AF PF CF
# scasd addr8: di addr16: di addr32: edi addr64: rdi flags: OF SF ZF AF PF CF
seto  src
setno src
setb src
setc src
setnae src
setnb src
setnc src
setae src
sete src
setz src
setne src
setnz src
setbe src
setna src
setnbe src
seta src
sets src
setns src
setp src
setpe src
setnp src
setpo src
setl src
setnge src
setnl src
setge src
setle src
setng src
setnle src
setg src

sfence
sgdt src
shld dest
shrd dest
shufpd dest
shufps dest
sidt dest
sldt dest
smsw src
sqrtpd dest
sqrtps dest
sqrtsd dest
sqrtss dest
stc    flags: CF
std    flags: DF
sti    flags: IF VIF
stmxcsr dest
stos  src addr8: di addr16: di addr32: edi addr64: rdi
# taken care of by mode append:
# stosb src addr8: di addr16: di addr32: edi addr64: rdi
# stosw src addr8: di addr16: di addr32: edi addr64: rdi
# stosd src addr8: di addr16: di addr32: edi addr64: rdi
# stosq src addr8: di addr16: di addr32: edi addr64: rdi

str   src
sub   dest flags: OF SF ZF AF PF CF
subpd dest
subps dest
subsd dest
subss dest
swapgs
#Not sure if the def set of syscall is correct
syscall rax rcx rdx rsi rdi r8 r9 r10 r11 flags: CF ZF SF OF PF AF
sysenter
sysexit
sysret


# T
test   flags: SF ZF PF OF CF undef: AF

# U
ucomisd flags: ZF PF CF clear: OF AF SF
ucomiss flags: ZF PF CF clear: OF AF SF
ud2
unpckhpd dest
unpckhps dest
unpcklpd dest
unpcklps dest

# V
verr  flags: ZF
verw  flags: ZF

# W
wait
fwait
wbinvd
wrmsr

# X
xadd dest  flags: CF PF AF SF ZF OF
xchg src dest
xgetbv edx eax
xlat  al
# taken care of by mode append
# xlatb al
xor dest flags: SF ZF PF clear: OF CF undef: AF
xorpd dest
xorps dest
xrstor src
xsave src
xsetbv
